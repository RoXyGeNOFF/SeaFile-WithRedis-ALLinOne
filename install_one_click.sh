#!/usr/bin/env bash
set -euo pipefail
START=$(date +%s)

# Однострочный установщик Docker-Compose стекa Seafile (быстрый запуск).
# Запускать как root или через sudo: sudo ./install_one_click.sh [DOMAIN] [EMAIL]
# Примечание: если образы не закешированы, загрузка может занять больше 1 минуты.
DOMAIN=${1:-""}
EMAIL=${2:-"admin@example.com"}
LETSENCRYPT_ENV=${LETSENCRYPT_ENV:-staging}  # staging по умолчанию для теста

# Проверки
if [ "$(id -u)" -ne 0 ]; then
  echo "[WARN] Рекомендуется запускать от root или через sudo. Попробую продолжить..."
fi

# Установка Docker (если не установлен)
if ! command -v docker >/dev/null 2>&1; then
  echo "[STEP] Устанавливаю Docker..."
  curl -fsSL https://get.docker.com | sh
  usermod -aG docker "${SUDO_USER:-$USER}" || true
else
  echo "[SKIP] Docker уже установлен"
fi

# Проверяем docker compose plugin (используем docker compose)
if ! docker compose version >/dev/null 2>&1; then
  echo "[INFO] Пытаюсь установить плагин docker compose (если нужно)..."
  # На современных системах compose включён в пакет docker; если нет — попытаемся поставить через пакетный менеджер
  if command -v apt >/dev/null 2>&1; then
    apt update -y && apt install -y docker-compose-plugin || true
  fi
fi

# Создаём директории данных, если их нет
echo "[STEP] Подготавливаю директории..."
mkdir -p data/seafile/seafile-data data/mysql data/redis data/elasticsearch data/certbot/conf data/certbot/www data/backups

# Генерируем минимальный .env если отсутствует
if [ ! -f .env ]; then
  echo "[STEP] Создаю минимальный .env (можно отредактировать после)..."
  cat > .env <<EOF
# Minimal .env generated by install_one_click.sh
SEAFILE_SERVER_HOSTNAME=${DOMAIN:-example.local}
LETSENCRYPT_EMAIL=${EMAIL}
LETSENCRYPT_ENV=${LETSENCRYPT_ENV}
MYSQL_ROOT_PASSWORD=ChangeMeRoot123!
MYSQL_USER=seafile
MYSQL_USER_PASSWORD=SeafilePass123!
MYSQL_DATABASE=seafile_db
REDIS_PASSWORD=
ELASTICSEARCH_JAVA_OPTS=-Xms256m -Xmx256m
EOF
  echo "[INFO] .env создан. Отредактируйте SEAFILE_SERVER_HOSTNAME в .env, если нужно."
else
  echo "[SKIP] .env уже существует"
fi

# Параллельно подтягиваем образы (ускоряет холодный старт)
echo "[STEP] Подтягиваю Docker-образы (параллельно, может занять время)..."
if command -v jq >/dev/null 2>&1 && [ -f docker-compose.yml ]; then
  # Собираем список образов из docker-compose.yml (если есть)
  docker compose config | awk '/image: /{print $2}' | sort -u | xargs -r -n1 -P4 docker pull || true
else
  docker compose pull || true
fi

# Стартуем стек
echo "[STEP] Запускаю docker compose..."
docker compose up -d --remove-orphans

# Ждём готовности основных сервисов (не дольше 60s)
echo "[STEP] Ожидаю готовности mysql/redis (макс 60s)..."
END_WAIT=$((SECONDS+60))
until (docker compose ps | grep -E 'mysql|redis|seafile' >/dev/null 2>&1) || [ $SECONDS -gt 60 ]; do
  sleep 1
done

# Если указан домен — пробуем запустить выдачу staging-сертификата в фоне
if [ -n "${DOMAIN}" ] && [ "${DOMAIN}" != "example.local" ]; then
  echo "[STEP] Запуск инициализации Let's Encrypt (staging/prod в зависимости от .env)..."
  chmod +x ./scripts/init-letsencrypt.sh || true
  (./scripts/init-letsencrypt.sh >/var/log/init-letsencrypt.log 2>&1) & disown || true
  echo "[INFO] Инициалиация Certbot запущена в фоне (логи: /var/log/init-letsencrypt.log)"
else
  echo "[INFO] Домeн не указан или установлен как пример; пропускаю автоматическую выдачу сертификатов."
fi

ELAPSED=$(( $(date +%s) - START ))
echo "-------------------------------------------"
echo "Готово. Время выполнения: ${ELAPSED}s"
echo "Проверьте контейнеры: docker compose ps"
echo "Логи: docker compose logs -f"
if [ -n "${DOMAIN}" ] && [ "${DOMAIN}" != "example.local" ]; then
  echo "Если у вас корректный DNS и порт 80 открыт, сертификат будет выпущен фоном."
else
  echo "Отредактируйте .env и запустите scripts/init-letsencrypt.sh для получения certbot-сертификата."
fi
echo "-------------------------------------------"